@go.Package { name = "mikea/declix/systemd" }
abstract module mikea.declix.systemd

import "package://pkg.pkl-lang.org/pkl-go/pkl.golang@0.8.0#/go.pkl" 
import "../resources/Resources.pkl"
import "../resources/filesystem/FileSystem.pkl"
import "../content/Content.pkl"
import "pkl:reflect"

class UnitFile extends FileSystem.File {
    afterAction: AfterAction
}

class AfterAction {
    daemonReload: Boolean = true
    restart: String?
    reload: String?
    reloadOrRestart: String?
}

abstract class Unit extends Resources.Resource {
    name: String
    user: String?

    fixed fqName: String = 
        if (name.endsWith(".service") || name.endsWith(".timer") || name.endsWith(".socket") || name.endsWith(".mount")) 
            throw("Unit '\(name)' name should not contain .type suffix")
        else "\(name).\(type)" 

    fixed systemctl: String = if (user != null) "sudo -u \(user) -i systemctl --user"
        else "sudo -i systemctl"

    fixed _isEnabled: String = """
        if \(systemctl) is-enabled \(fqName) &> /dev/null; then
            echo "enabled = true"
        else
            echo "enabled = false"
        fi
        """
    fixed _isActive: String = """
        if \(systemctl) is-active \(fqName) &> /dev/null; then
            echo "active = true"
        else
            echo "active = false"
        fi
        """

    fixed _stateCmd: String = """
        \(_isEnabled)
        \(_isActive)
        """

    fixed _cmds: _UnitStateScripts = state._cmds(this)
}

open class UnitState {
    enabled: Boolean?
    active: Boolean?

    function _enable(u: Unit): String = 
        if (enabled) "\(u.systemctl) enable \(u.fqName)" 
        else "\(u.systemctl) disable \(u.fqName)"

    function _start(u: Unit): String =
        if (active) "\(u.systemctl) start \(u.fqName)" 
        else "\(u.systemctl) stop \(u.fqName)"

    function _cmds(u: Unit): _UnitStateScripts = new {
        when (enabled != null) {
            enable = _enable(u)
        }
        when (active != null) {
            start = _start(u)
        }
    }
}

class _UnitStateScripts {
    enable: String?
    start: String?
}

class Service extends Unit {
    type: "service"
    state: UnitState

    fixed id: String = type + ":" + name
}

class Socket extends Unit {
    type: "socket"
    state: UnitState

    fixed id: String = type + ":" + name
}

class Timer extends Unit {
    type: "timer"
    state: UnitState

    fixed id: String = type + ":" + name
}

class Mount extends Unit {
    type: "mount"
    state: UnitState

    fixed id: String = type + ":" + name
}

abstract class Section {
    function render(): String = "[\(name)]\n" + new Listing {
        for (k, v in this.toMap()) {
            when (k != "name" && v != null) {
                "\(k.capitalize())=\(v)"
            }
        }
        ""
    }.join("\n")
}

// https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html
class UnitSection extends Section {
    fixed name = "Unit"

    after: String?
    allowIsolate: String?
    before: String?
    bindsTo: String?
    collectMode: String?
    conflicts: String?
    defaultDependencies: String?
    description: String?
    documentation: String?
    failureAction: String?
    failureActionExitStatus: String?
    ignoreOnIsolate: String?
    jobRunningTimeoutSec: String?
    jobTimeoutAction: String?
    jobTimeoutRebootArgument: String?
    jobTimeoutSec: String?
    joinsNamespaceOf: String?
    onFailure: String?
    onFailureJobMode: String?
    onSuccess: String?
    onSuccessJobMode: String?
    partOf: String?
    propagatesReloadTo: String?
    propagatesStopTo: String?
    rebootArgument: String?
    refuseManualStart: String?
    refuseManualStop: String?
    reloadPropagatedFrom: String?
    requires: String?
    requiresMountsFor: String?
    requisite: String?
    sourcePath: String?
    startLimitAction: String?
    startLimitBurst: String?
    startLimitIntervalSec: String?
    stopPropagatedFrom: String?
    stopWhenUnneeded: String?
    successAction: String?
    successActionExitStatus: String?
    surviveFinalKillSignal: String?
    upholds: String?
    wants: String?
    wantsMountsFor: String?
}

// https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html
class InstallSection extends Section {
    fixed name = "Install"

    alias: String?
    also: String?
    defaultInstance: String?
    requiredBy: String?
    upheldBy: String?
    wantedBy: String?
}

// https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html
class ServiceSection extends Section {
    fixed name = "Service"

    type: ServiceType?

    busName: String?
    environment: Mapping<String, String>
    environmentFile: String?
    execCondition: String?
    execReload: String?
    execStart: String?
    execStartPost: String?
    execStartPre: String?
    execStop: String?
    execStopPost: String?
    exitType: ServiceExitType?
    fileDescriptorStoreMax: String?
    fileDescriptorStorePreserve: String?
    guessMainPID: String?
    nonBlocking: String?
    notifyAccess: String?
    oOMPolicy: String?
    openFile: String?
    pIDFile: String?
    reloadSignal: String?
    remainAfterExit: String?
    restart: String?
    restartForceExitStatus: String?
    restartMaxDelaySec: String?
    restartMode: String?
    restartPreventExitStatus: String?
    restartSec: String?
    restartSteps: String?
    rootDirectoryStartOnly: String?
    runtimeMaxSec: String?
    runtimeRandomizedExtraSec: String?
    sockets: String?
    successExitStatus: String?
    timeoutAbortSec: UInt?
    timeoutSec: UInt?
    timeoutStartFailureMode: UInt?
    timeoutStartSec: UInt?
    timeoutStopFailureMode: UInt?
    timeoutStopSec: UInt?
    uSBFunctionDescriptors: String?
    uSBFunctionStrings: String?
    watchdogSec: String?

    // todo: extract KillMode
    finalKillSignal: String?
    killMode: String?
    killSignal: String?
    restartKillSignal: String?
    sendSIGHUP: String?
    sendSIGKILL: String?
    watchdogSignal: String?

    function render(): String = "[\(name)]\n" + new Listing {
        for (k, v in this.toMap()) {
            when (k != "name" && k != "environment" && v != null) {
                "\(k.capitalize())=\(v)"
            }
        }
        for (k, v in environment) {
            "Environment=\(k)=\(v)"
        }
        ""
    }.join("\n")
}

typealias ServiceType = "simple" | "exec" | "forking" | "oneshot" | "dbus" | "notify" | "notify-reload" | "idle"
typealias ServiceExitType = "main" | "cgroup"

class ServiceFile extends Content.Render {
    unit: UnitSection
    install: InstallSection
    service: ServiceSection

    function render(): String = new Listing {
        unit.render()
        install.render()
        service.render()
    }.join("\n")
}


// https://www.freedesktop.org/software/systemd/man/latest/systemd.timer.html
class TimerSection extends Section {
    fixed name = "Timer"

    accuracySec: (String|Number)?
    fixedRandomDelay: String?
    onActiveSec: (String|Number)?
    onBootSec: (String|Number)?
    onCalendar: String?
    onClockChange: String?
    onStartupSec: (String|Number)?
    onTimezoneChange: String?
    onUnitActiveSec: (String|Number)?
    onUnitInactiveSec: (String|Number)?
    persistent: String?
    randomizedDelaySec: (String|Number)?
    remainAfterElapse: String?
    unit: String?
    wakeSystem: String?
}

class TimerFile extends Content.Render {
    unit: UnitSection
    install: InstallSection
    timer: TimerSection

    function render(): String = new Listing {
        unit.render()
        install.render()
        timer.render()
    }.join("\n")
}
